using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using CacheSourceGenerator.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CacheSourceGenerator.Generation;

internal class ClassesCodeBuilder
{
    private readonly LazyTypes _types;

    public ClassesCodeBuilder(LazyTypes types)
    {
        _types = types;
    }
    
    public string Build(EvaluatedClassCollection classCollection)
    {
        var stringBuilder = new StringBuilder();
        var (compilationUnitSyntax, _) = BuildCompilationUnit(classCollection);

        stringBuilder.AppendLine("#nullable enable");
        stringBuilder.AppendLine("//autogenerated");
        stringBuilder.AppendLine(compilationUnitSyntax.NormalizeWhitespace().ToFullString());
        return stringBuilder.ToString();
    }

    private  (CompilationUnitSyntax, ClassDeclarationSyntax) BuildCompilationUnit(EvaluatedClassCollection classDataCollection)
    {
        // Get the compilationunit of the existing class
        var compilation = classDataCollection.ClassDeclaration.Ancestors().OfType<CompilationUnitSyntax>().First();

        // Create a new compilation
        var newCompilation = SyntaxFactory.CompilationUnit();
        
        // Add the using statements from the existing compilation unit
        newCompilation = newCompilation.WithUsings(compilation.Usings);

        // If we use the Strategy SelfGeneratedFactory we add the relevant using if it's 
        // not already installed
        if (classDataCollection.CacheAccessStrategy == CacheAccessStrategy.FromSelfGeneratedFactory)
        {
            var microsoftExtensionsCachingMemory = "Microsoft.Extensions.Caching.Memory";

            if (newCompilation.Usings.All(x => x.Name?.ToString() != microsoftExtensionsCachingMemory))
            {
                newCompilation =
                    newCompilation.AddUsings(
                        SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(microsoftExtensionsCachingMemory)));
            }
        }

        // Create a namespace matching the existing (as a FileScopedNamespaceDeclaration)
        var namespaceDeclarationSyntax = SyntaxFactory.FileScopedNamespaceDeclaration(
            SyntaxFactory.ParseName(classDataCollection.NamedTypeSymbol.ContainingNamespace.ToDisplayString()));

        // Build the class 
        var classDeclaration = BuildPartialClass(classDataCollection);

        // Add the class to the namespace
        namespaceDeclarationSyntax = namespaceDeclarationSyntax.AddMembers(classDeclaration);

        // And update the new compilation
        newCompilation = newCompilation.AddMembers(namespaceDeclarationSyntax);
        return (newCompilation, classDeclaration);
    }

    private ClassDeclarationSyntax BuildPartialClass(EvaluatedClassCollection collection)
    {
        var existingClass = collection.ClassDeclaration;
        
        // Create a new class with the same modifiers as the existing class
        var newPartialClass = SyntaxFactory.ClassDeclaration(existingClass.Identifier)
            .WithModifiers(existingClass.Modifiers);
        
        // If we are using SelfGeneratedFactory. We parse the and insert a static class that can
        // init and return an IMemoryCache instance
        if (collection.CacheAccessStrategy == CacheAccessStrategy.FromSelfGeneratedFactory)
        {
            newPartialClass = newPartialClass.AddMembers(SyntaxFactory.ParseMemberDeclaration(Code.AddCacheClass) ??
                                                         throw new InvalidOperationException(
                                                             "Failed to parse AddCacheClass code"));
        }
        
        // Loop through all methods we have established as valid 
        foreach (var methodData in collection.Methods)
        {
            var wrappingMethod = CreateWrappingMethod(collection, methodData);
            var createEvictMethod = CreateEvictMethod(collection, methodData);
            newPartialClass = newPartialClass.AddMembers(wrappingMethod, createEvictMethod);
        }
        
        return newPartialClass;
    }

    private MethodDeclarationSyntax CreateEvictMethod(EvaluatedClassCollection collection, MethodData methodData)
    {
        var overridingMethodName = methodData.Attribute.GetAttributePropertyValue<string>(Code.MethodName)!;
        var newIdentifier = SyntaxFactory.Identifier($"{overridingMethodName}_Evict");
        var wrappingMethod = CreateMethodSignatureFromExisting(methodData, newIdentifier);
        wrappingMethod = wrappingMethod.WithReturnType(SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword)));
        var evictMethodStatement = GenerateEvictMethodStatement(collection, methodData);

        return wrappingMethod.WithBody((BlockSyntax) SyntaxFactory.ParseStatement(evictMethodStatement));
        
    }

    private MethodDeclarationSyntax CreateWrappingMethod(EvaluatedClassCollection collection, MethodData methodData)
    {
        var newIdentifier =
            SyntaxFactory.Identifier(methodData.Attribute.GetAttributePropertyValue<string>(Code.MethodName)!);
        var wrappingMethod = CreateMethodSignatureFromExisting(methodData, newIdentifier);
        var methodStatement = GenerateMethodStatement(collection, methodData);

        return wrappingMethod.WithBody((BlockSyntax)SyntaxFactory.ParseStatement(methodStatement));
    }

    private MethodDeclarationSyntax CreateMethodSignatureFromExisting(MethodData methodData, SyntaxToken newIdentifier)
    {
        // Reuse the source method but give it the new name
        var newMethod = methodData.MethodDeclarationSyntax.WithIdentifier(newIdentifier);
        // Clear attributes
        newMethod = newMethod.WithAttributeLists(SyntaxFactory.List<AttributeListSyntax>());

        HashSet<SyntaxKind> accessModifiers = new HashSet<SyntaxKind>(new[]
        {
            SyntaxKind.PublicKeyword, SyntaxKind.PrivateKeyword, SyntaxKind.ProtectedKeyword,
            SyntaxKind.InternalKeyword, SyntaxKind.AsyncKeyword
        });

        // Create a list stripping of the access modifers
        var syntaxTokens = newMethod.Modifiers.Where(x => !accessModifiers.Contains(x.Kind())).ToList();

        var newModifiers = new List<SyntaxToken>() { SyntaxFactory.Token(SyntaxKind.PublicKeyword) };
        if (methodData.MethodSymbol.IsAsyncWithResult(_types))
        {
            newModifiers.Add(SyntaxFactory.Token(SyntaxKind.AsyncKeyword));
        }

        // replace the modifiers but add public
        newMethod = newMethod.WithModifiers(
            SyntaxFactory.TokenList(newModifiers.Concat(syntaxTokens)));
        return newMethod;
    }

    private string GenerateEvictMethodStatement(EvaluatedClassCollection collection, MethodData methodData)
    {
        var key = KeyInitialiser(collection, methodData.MethodSymbol);
        return $$"""
                 {
                  var _key_ = {{key}};
                  IMemoryCache _cache_ = {{GetCacheAccess(collection)}};
                  _cache_.Remove(_key_);
                  }
                 """;
    }

    private  string GenerateMethodStatement(EvaluatedClassCollection collection, MethodData methodData)
    {
        var methodSymbol = methodData.MethodSymbol;
        
        // Temporarily commented out. 
        // var nullThrow = methodSymbol.ReturnType.IsNullable(_types)
        //     ? string.Empty
        //     : """?? throw new InvalidOperationException("Expected non empty result")""";

        var keyGenerator =
            KeyInitialiser(collection, methodSymbol);
        
        
        if (methodSymbol.IsAsyncWithResult(_types))
        {
            return $$"""
                     {
                         var _key_ = {{ keyGenerator }};
                            
                            IMemoryCache _cache_ = {{ GetCacheAccess(collection)}};            
                            var _result_ = await _cache_.GetOrCreateAsync(_key_, async _entry_ =>
                            {
                                {{ GenerateCacheEntryProcessing(methodData, true) }}
                                return await {{methodSymbol.Name}}({{string.Join(",", methodSymbol.Parameters.Select(x => x.Name))}});
                            }); 
                            return _result_;

                     }
                     """;    
        }

        return $$"""
                 {
                     var _key_ = {{ keyGenerator }};
                 
                        IMemoryCache _cache_ = {{GetCacheAccess(collection)}};    
                        return _cache_.GetOrCreate(_key_, _entry_ =>
                        {
                            {{ GenerateCacheEntryProcessing(methodData, false) }}
                            return {{methodSymbol.Name}}({{string.Join(",", methodSymbol.Parameters.Select(x => x.Name))}});
                        });

                 }
                 """;


    }

    private static string KeyInitialiser(EvaluatedClassCollection collection, IMethodSymbol methodSymbol)
    {
        return $$"""new { _MethodName = "{{methodSymbol.Name}}", _ClassName = "{{collection.NamedTypeSymbol.Name}}", {{string.Join(",", methodSymbol.Parameters.Select(x => x.Name))}} }""";
    }

    private string GenerateCacheEntryProcessing(MethodData methodData, bool callerAsync)
    {
        if (methodData.EvaluatedCacheEnricher == null)
            return string.Empty;
        if (methodData.EvaluatedCacheEnricher.IsAsync)
        {
            if (callerAsync)
            {
                return $"""await { methodData.EvaluatedCacheEnricher.MethodName }(_entry_);""";    
            }

            return $"""{methodData.EvaluatedCacheEnricher.MethodName}(_entry_).GetAwaiter().GetResult();""";
        }
        else
        {
            return $"""{methodData.EvaluatedCacheEnricher.MethodName}(_entry_);""";
        }
        
    }

    private string GetCacheAccess(EvaluatedClassCollection classCollection)
    {
        return classCollection switch
        {
            { CacheAccessStrategy: CacheAccessStrategy.FromSelfGeneratedFactory } => "CacheInit.MemoryCache",
            {
                CacheAccessStrategy: CacheAccessStrategy.FromMember,
                CacheAccessSource: CacheMemberAccessSource.PropertyOrField
            } => classCollection.CacheMemberAccessName!,
            { CacheAccessStrategy: CacheAccessStrategy.FromMember, CacheAccessSource: CacheMemberAccessSource.Method }
                => $"{classCollection.CacheMemberAccessName}()",
            _ => throw new InvalidOperationException("Should not be fired")
        };
    }
}