# Cache source generator
 _[![CacheSourceGenerator Nuget Version](https://img.shields.io/nuget/v/CacheSourceGenerator?style=flat-square&label=NuGet%3A%20CacheSourceGenerator)](https://www.nuget.org/packages/CacheSourceGenerator)_

A source generator that can generate simple cache boilerplate to wrap around a method

## Getting started

### Autogenerated cache access code

This requires that you install the nuget package Microsoft.Extensions.Caching.Memory.

Decorate a method that returns a value on a partial class with the Cacho Attribute

```csharp
public partial class SomeClass
{

  [CacheSourceGenerator.Cache(MethodName = "SomeMethod")]
  private string DoSomeMethod(string id, int age)
  {
      return $"{id}{age}";
  }
}
```

This will generate the code below.

```csharp
public partial class SomeClass
{
    private static class CacheInit
    {
        static CacheInit()
        {
            _memoryCache = new Lazy<IMemoryCache>(() => new MemoryCache(new MemoryCacheOptions()));
        }

        private static Lazy<IMemoryCache> _memoryCache;
        public static IMemoryCache MemoryCache => _memoryCache.Value;
    }

    public string SomeMethod(string id, int age)
    {
        var key = new
        {
            _MethodName = "DoSomeMethod",
            _ClassName = "SomeClass",
            id,
            age
        };
        IMemoryCache cache = CacheInit.MemoryCache;
        return cache.GetOrCreate(key, entry =>
        {
            return DoSomeMethod(id, age);
        }) ?? throw new InvalidOperationException("Expected non empty result");
    }
}
```

### Providing the cache from the class

An alternative is to provide a IMemoryCacheInstance from the class. This can be done through a

* Field
* Property
* Method (parameter less)

```csharp
public static SomeOtherClass
{
    private static IMemoryCache GetCache() => new MemoryCache(new MemoryCacheOptions());

    [CacheSourceGenerator.Cache(MethodName = "SomeMethod", CacheInstance = "GetCache")]
    public static Task<string> ExecuteCall()
    {
        return Task.FromResult("Hello");
    }
}
```


if the method is async or returning a `Task<T>` the generated method will take that into consideration. It will also leave of the exception if the return type is nullable.

Per default the caching mechanism uses IMemoryCache. So `Microsoft.Extensions.Caching.Abstractions` and  `Microsoft.Extensions.Caching.Memory`. The generator exposes the `CacheInit` static class that per default returns a singleton instance of memory

```csharp
namespace CacheSourceGenerator;

public delegate IMemoryCache CacheInitializer();

internal static class CacheInit
{
    static CacheInit()
    {
        _memoryCache = new Lazy<IMemoryCache>(() => Initializer());
    }
    
    private static Lazy<IMemoryCache> _memoryCache; //= new Lazy<IMemoryCache>(Initializer)
    
    private static CacheInitializer Initializer = () => new MemoryCache(new MemoryCacheOptions());
    public static IMemoryCache MemoryCache => _memoryCache.Value;

    public static void ReplaceInitializer(CacheInitializer initializer)
    {
        Initializer = initializer;
        _memoryCache = new Lazy<IMemoryCache>(() => Initializer());
    }
}
```

You can replace how the IMemoryCache is initialized by calling the ReplaceInitializer method on CacheInit
